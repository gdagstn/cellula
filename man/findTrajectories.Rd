% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trajectories.R
\name{findTrajectories}
\alias{findTrajectories}
\title{Find trajectories}
\usage{
findTrajectories(
  sce,
  dr = "PCA",
  clusters,
  method = "slingshot",
  ndims = 20,
  dr_embed = NULL,
  start = "auto",
  Monocle_lg_control = NULL,
  omega = TRUE,
  omega_scale = 1.5,
  invert = FALSE,
  do_de = FALSE,
  batch_de = NULL,
  add_metadata = TRUE,
  return_sds = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{sce}{a \code{SingleCellExperiment} object}

\item{dr}{character, the name of the \code{reducedDim} slot to use for trajectory
estimation. Default is "PCA".}

\item{clusters}{character, the name of the \code{colData} column with cluster label
indication.}

\item{method}{character, the method for estimation. Can be one of \code{"slingshot"},
\code{"monocle"}, or \code{"MODDPT"}. This will result in differences in 
the resulting object, see Details for more information.}

\item{ndims}{numeric, the number of dimensions to use in `dr`. If the number
of columns in \code{dr} is < \code{ndims}, it will be used instead.}

\item{dr_embed}{character, the name of the \code{reducedDim} slot where curves should
be embedded for plotting. If \code{method = "monocle"} and \code{dr_embed = "FR"}, 
an alternative 2D embedding for the \code{monocle} trajectories is created (see
Details).
Default is NULL, meaning no embedding will be performed.}

\item{start}{character, the name of the cluster to be used as starting point.
Default is \code{"auto"}, implying an entropy-based method will be used to guess
the best starting point.}

\item{Monocle_lg_control}{list or NULL (default). A list of control parameters
for the \code{learn_graph()} function from \code{monocle3}. 
See \code{?monocle3::learn_graph}
for more information. Only used when \code{method = "monocle"}.}

\item{omega}{logical, should the \code{omega} method for MST calculation be used?
Default is TRUE. See \code{?slingshot::getLineages} for more information.}

\item{omega_scale}{numeric, the value of the \code{omega_scale} parameter. 
Default is 1.5. See \code{?slingshot::getLineages} for more information.}

\item{invert}{logical. Should the pseuodtime vector be inverted? Only valid
for monocle3. Default is FALSE.}

\item{do_de}{logical. Should differential expression across trajectories be
performed? Default is FALSE.}

\item{batch_de}{character, the name of the \code{colData} column to be used as a
blocking factor in the differential expression analysis. Default is NULL.}

\item{add_metadata}{logical, should additional data from trajectory inference be
added to the \code{metadata(sce)}? Default is TRUE.}

\item{return_sds}{logical, should the \code{SlingshotDataSet} object be returned
in the metadata? Default is FALSE.}

\item{verbose}{logical, should progress messages be printed? Default is FALSE.}
}
\value{
a SingleCellExperiment object with pseudotime results
}
\description{
Finds pseudo-temporal trajectories in a reduced dimensional space
}
\details{
This function wraps calls to three popular trajectory estimation methods, i.e.
\code{slingshot}, \code{monocle3}, and diffusion pseudotime. 
Most parameters are shared, and implementation is simplified for now 
(few parameters can be tweaked). In the future there will be more freedom to 
tweak parameters, although it bears repeating that these are wrappers 
aimed at simplifying procedures.

For all methods the user is asked to define the dimensionality reduction slot 
via `dr`, and the number of dimensions via \code{ndims}. The user is also asked to
provide a starting cluster; if the choice is left to `auto`, the function will
use an entropy-based method to select maximum-entropy cell clusters as starting 
points. Finally, both methods have the ability to embed principal curves into 
a 2D representation of choice, albeit with different results. 

The \code{slingshot} implementation allows the user to choose whether or not 
to use the \code{omega} method to separate disjointed trajectories, and to decide 
the \code{omega_scale}. Optionally, the user can run lineage-dependent differential
expression via \code{TSCAN::testPseudotime()} setting \code{do_de = TRUE}. 

The final result is a `SingleCellExperiment` object with 
some additional fields:
\itemize{
 \item{"slingPseudotime_N"}{ \code{colData} columns where N is any number >= 1. 
     These contain the pseudotemporal ordering of cells in a lineage, with NA
     being assigned to cells that do not belong to the lineage.}
 \item{"Slingshot_embedded_curves"}{ \code{metadata} list element containing segment 
     coordinates used to plot trajectories in 2D.}
 \item{"Slingshot_lineages"}{  \code{metadata} list element containing lineages (as 
     orderings of labels) used for metromap plotting.}   
 \item{"Slingshot_MST"}{ \code{metadata} list element containing the MST. Only
     added if \code{add_metadata = TRUE}.}
 \item{"Slingshot_curves"}{ \code{metadata} list element containing list of principal
     curve coordinates. Only added if `add_metadata` is `TRUE`.} 
 \item{"Slingshot_weights"}{ \code{metadata} list element containing a cell x lineage
     matrix of lineage-associated weights. Only added if `add_metadata` is 
     `TRUE`.}
 \item{"Slingshot_params"}{ \code{metadata} list element containing parameters for
     the \code{slingshot} call. Only added if `add_metadata` is `TRUE`.}
 \item{"pseudotime_DE"}{ \code{metadata} list element containing a list of DE results
     per lineage. Each result is a `DataFrame` object with `logFC`, `p.value`
     and `FDR` values for each gene. Only added if `do_de` is set to `TRUE}         
}

The \code{monocle3} implementation is rather simplified, with an important 
difference: it allows users to specify any reduced dimension rather than
just UMAP. This is in keeping with the evidence that UMAP reductions greatly
distorted. 

When using PCA as a space for trajectory inference, the 2D 
embedding of the Monocle trajectories is re-calculated by picking the nearest
neighbors in PCA to the "waypoints" calculated by the algorithm. This can 
result in slightly more convoluted trajectories when visualized in UMAP, which
is attributable to the distortion.

To overcome this, an alternative embedding 
is available through \code{dr_embed = "FR"}. In this embedding the principal graph
of the trajectory is laid out using the Fruchterman-Reingold layout (hence
the name) and cells are randomly placed around their closest vertex (as 
calculated in PCA space) according to a 2D Gaussian distribution in which the
standard deviation is proportional to the square root of the number of cells
close to the vertex. Then, cell identities are ordered according to their
pseudotime value. Finally, this 2D embedding is given as an input to UMAP to 
optimize non-overlapping distribution of points. This results in a more pleasing
embedding in which cells are distributed along trajectories that were still
derived in high-dimensional space. This implementation was inspired by the
PAGA initialization for UMAP by Wolf and colleagues (2019).

The final result is a \code{SingleCellExperiment} object with 
some additional fields:
\itemize{
 \item{"monoclePseudotime"}{ \code{colData} column with a single pseudotime value
    for every cell.}
 \item{"Monocle_embedded_curves"}{ \code{metadata} list element containing segment 
     coordinates used to plot trajectories in 2D.}  
 \item{"Monocle_principal_graph"}{ \code{metadata} list element containing the 
     principal graph coordinates. Only added if `add_metadata` is set to 
     `TRUE`.} 
 \item{"Monocle_principal_graph_aux"}{ \code{metadata} list element containing 
     all the other objects used by \code{monocle3} for trajectory inference.
     Only added if \code{add_metadata = TRUE}}                
}

The \code{MODDPT} method uses a hybrid approach that takes inspiration from PAGA
and \code{slingshot}. This approach uses the pairwise modularity graph for the
SNN graph and the clusters. A minimum spanning tree is built on the modularity
graph using the inverse of pairwise modularity as edge weight. Then, all
shortest paths on the tree are calculated from the starting cluster. Diffusion
maps are built independently on each path and diffusion pseudotimes are computed,
and eventually reordered to be consistent with the path ordering. A simple
path embedding is calculated in 2D by dividing the pseudotime values along
a path in an equal number of intervals, and then taking the median coordinate
for all cells in each pseudotime interval. Embedded curves are smoothed using
Gaussian kernel smoothing.

The final result is a \code{SingleCellExperiment} object with 
some additional fields:

\itemize{
 \item{"DPTpseudotime_N"}{ \code{colData} columns where N is any number >= 1. 
     These contain the pseudotemporal ordering of cells in a lineage, with NA
     being assigned to cells that do not belong to the lineage.}
 \item{"MODDPT_MST"}{ \code{metadata} \code{igraph} object with the minimum 
    spanning tree from the pairwise modularity graph.}
 \item{"MODDPT_lineages"}{ \code{metadata} list element containing the lineages
    or paths from the starting cluster to all others in the MST.}
 \item{"MODDPT_DiffusionMaps"}{ \code{metadata} list element containing 
     diffusion maps calculated by \code{destiny} in each lineage separately.}
 \item{"MODDPT_embedded_curves"}{ \code{metadata} data.frame element containing 
     segments coordinates to plot trajectories on a 2D embedding.}
}
}
\author{
Giuseppe D'Agostino, and Stefan Boeing for the initial implementation of Monocle 3
}
