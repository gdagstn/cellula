% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trajectories.R
\name{findTrajectories}
\alias{findTrajectories}
\title{Find trajectories}
\usage{
findTrajectories(
  sce,
  dr = "PCA",
  clusters,
  method = "slingshot",
  ndims = 20,
  dr_embed = NULL,
  start = "auto",
  Monocle_lg_control = NULL,
  omega = TRUE,
  omega_scale = 1.5,
  invert = FALSE,
  do_de = FALSE,
  batch_de = NULL,
  add_metadata = TRUE,
  verbose = FALSE,
  BPPARAM = SerialParam()
)
}
\arguments{
\item{sce}{a \code{SingleCellExperiment} object}

\item{dr}{character, the name of the \code{reducedDim} slot to use for trajectory
estimation. Default is "PCA".}

\item{clusters}{character, the name of the \code{colData} column with cluster label
indication.}

\item{method}{character, the method for estimation. Can be either \code{"slingshot"}
or \code{"monocle"}. This will result in differences in the resulting object,
see Details for more information.}

\item{ndims}{numeric, the number of dimensions to use in `dr`. If the number
of columns in \code{dr} is < \code{ndims}, it will be used instead.}

\item{dr_embed}{character, the name of the `reducedDim` slot where curves should
be embedded for plotting. If \code{method = "monocle"} and \code{dr_embed = "FR"}, 
an alternative 2D embedding for the \code{monocle} trajectories is created (see
Details).
Default is NULL, meaning no embedding will be performed.}

\item{start}{character, the name of the cluster to be used as starting point.
Default is \code{"auto"}, implying an entropy-based method will be used to guess
the best starting point.}

\item{Monocle_lg_control}{list or NULL (default). A list of control parameters
for the \code{learn_graph()} function from \code{monocle3}. 
See \code{?monocle3::learn_graph()}
for more information. Only used when \code{method = "monocle"}.}

\item{omega}{logical, should the \code{omega} method for MST calculation be used?
Default is TRUE. See \code{?slingshot::getLineages} for more information.}

\item{omega_scale}{numeric, the value of the \code{omega_scale} parameter. 
Default is 1.5. See \code{?slingshot::getLineages} for more information.}

\item{do_de}{logical. Should differential expression across trajectories be
performed? Default is FALSE.}

\item{batch_de}{character, the name of the \code{colData} column to be used as a
blocking factor in the differential expression analysis. Default is NULL.}

\item{verbose}{logical, should progress messages be printed? Default is FALSE.}

\item{BPPARAM}{a \code{BiocParallelParam} object. Default is NULL.}
}
\value{
a SingleCellExperiment object with pseudotime results
}
\description{
Finds pseudo-temporal trajectories in a reduced dimensional space
}
\details{
This function wraps calls to two popular trajectory estimation methods, i.e.
\code{slingshot} and \code{monocle3}. Most parameters are shared, and 
implementation is simplified for now (few parameters can be tweaked). In the 
future there will be more freedom to tweak parameters, although it bears
repeating that these are wrappers aimed at simplifying procedures.

For all methods the user is asked to define the dimensionality reduction slot 
via `dr`, and the number of dimensions via \code{ndims}. The user is also asked to
provide a starting cluster; if the choice is left to `auto`, the function will
use the entropy-based method as implemented in \code{TSCAN} to select maximum-
entropy cell clusters as starting points. Finally, both methods have the ability
to embed principal curves into a 2D representation of choice, albeit with 
slightly different results. 

The \code{slingshot} implementation allows the user to choose whether or not 
to use the \code{omega} method to separate disjointed trajectories, and to decide 
the \code{omega_scale}. Optionally, the user can run lineage-dependent differential
expression via \code{TSCAN::testPseudotime()} setting \code{do_de = TRUE}. 

The final result is a `SingleCellExperiment` object with 
some additional fields:
\itemize{
 \item{"slingPseudotime_N"}{ \code{colData} columns where N is any number >= 1. 
     These contain the pseudotemporal ordering of cells in a lineage, with NA
     being assigned to cells that do not belong to the lineage.}
 \item{"Slingshot_embedded_curves"}{ \code{metadata} list element containing segment 
     coordinates used to plot trajectories in 2D.}
 \item{"Slingshot_lineages"}{  \code{metadata} list element containing lineages (as 
     orderings of labels) used for metromap plotting.}   
 \item{"Slingshot_MST"}{ \code{metadata} list element containing the MST. Only
     added if \code{add_metadata = TRUE}.}
 \item{"Slingshot_curves"}{ \code{metadata} list element containing list of principal
     curve coordinates. Only added if `add_metadata` is `TRUE`.} 
 \item{"Slingshot_weights"}{ \code{metadata} list element containing a cell x lineage
     matrix of lineage-associated weights. Only added if `add_metadata` is 
     `TRUE`.}
 \item{"Slingshot_params"}{ \code{metadata} list element containing parameters for
     the \code{slingshot} call. Only added if `add_metadata` is `TRUE`.}
 \item{"pseudotime_DE"}{ \code{metadata} list element containing a list of DE results
     per lineage. Each result is a `DataFrame` object with `logFC`, `p.value`
     and `FDR` values for each gene. Only added if `do_de` is set to `TRUE}         
}

The \code{monocle3} implementation is rather simplified, with an important 
difference: it allows users to specify any reduced dimension rather than
just UMAP. This is in keeping with the evidence that UMAP reductions greatly
distorted. 

When using PCA as a space for trajectory inference, the 2D 
embedding of the Monocle trajectories is re-calculated by picking the nearest
neighbors in PCA to the "waypoints" calculated by the algorithm. This can 
result in slightly more convoluted trajectories when visualized in UMAP, which
is attributable to the distortion.

To overcome this, an alternative embedding 
is available through \code{dr_embed = "FR"}. In this embedding the principal graph
of the trajectory is laid out using the Fruchterman-Reingold layout (hence
the name) and cells are randomly placed around their closest vertex (as 
calculated in PCA space) according to a 2D Gaussian distribution in which the
standard deviation is proportional to the square root of the number of cells
close to the vertex. Then, cell identities are ordered according to their
pseudotime value. Finally, this 2D embedding is given as an input to UMAP to 
optimize non-overlapping distribution of points. This results in a more pleasing
embedding in which cells are distributed along trajectories that were still
derived in high-dimensional space. This implementation was inspired by the
PAGA initialization for UMAP by Wolf and colleagues (2019).

The final result is a \code{SingleCellExperiment} object with 
some additional fields:
\itemize{
 \item{"monoclePseudotime"}{ \code{colData} column with a single pseudotime value
    for every cell.}
 \item{"Monocle_embedded_curves"}{ \code{metadata} list element containing segment 
     coordinates used to plot trajectories in 2D.}  
 \item{"Monocle_principal_graph"}{ \code{metadata} list element containing the 
     principal graph coordinates. Only added if `add_metadata` is set to 
     `TRUE`.} 
 \item{"Monocle_principal_graph_aux"}{ \code{metadata} list element containing 
     all the other objects used by \code{monocle3} for trajectory inference.
     Only added if \code{add_metadata = TRUE}}                
}
}
\author{
Giuseppe D'Agostino, and Stefan Boeing for the initial implementation of Monocle 3
}
